### 多线程
    1:要想了解多线程，必须先了解线程，而要想了解线程，必须先了解进程，因为线程是依赖于进程而存在。
    
    2:什么是进程?
    	通过任务管理器我们就看到了进程的存在。
    	而通过观察，我们发现只有运行的程序才会出现进程。
    	进程：就是正在运行的程序。
    	进程是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。
    	
    3:多进程有什么意义呢?
    	单进程的计算机只能做一件事情，而我们现在的计算机都可以做多件事情。
    	举例：一边玩游戏(游戏进程)，一边听音乐(音乐进程)。
    	也就是说现在的计算机都是支持多进程的，可以在一个时间段内执行多个任务。
    	并且呢，可以提高CPU的使用率。
    	
    	问题：
    		一边玩游戏，一边听音乐是同时进行的吗?
    		不是。因为单CPU在某一个时间点上只能做一件事情。
    		而我们在玩游戏，或者听音乐的时候，是CPU在做着程序间的高效切换让我们觉得是同时进行的。
    		
    4:什么是线程呢?
    	在同一个进程内又可以执行多个任务，而这每一个任务我就可以看出是一个线程。
    	线程：是程序的执行单元，执行路径。是程序使用CPU的最基本单位。
    	单线程：如果程序只有一条执行路径。
    	多线程：如果程序有多条执行路径。
    	
    5:多线程有什么意义呢?
    	多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。
    	程序的执行其实都是在抢CPU的资源，CPU的执行权。
    	多个进程是在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权。
    	我们是不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性。
    进程：
    	正在运行的程序，是系统进行资源分配和调用的独立单位。
    	每一个进程都有它自己的内存空间和系统资源。
    线程：
    	是进程中的单个顺序控制流，是一条执行路径
    	一个进程如果只有一条执行路径，则称为单线程程序。
    	一个进程如果有多条执行路径，则称为多线程程序。
    
    举例：
     	扫雷程序，迅雷下载
     
    大家注意两个词汇的区别：并行和并发。
    		前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
    		后者是物理上同时发生，指在某一个时间点同时运行多个程序。
    
    Java程序的运行原理：
    		由java命令启动JVM，JVM启动就相当于启动了一个进程。
    		接着有该进程创建了一个主线程去调用main方法。
    
    思考题：
    		jvm虚拟机的启动是单线程的还是多线程的?
    			多线程的。
    			原因是垃圾回收线程也要先启动，否则很容易会出现内存溢出。
    			现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以，jvm的启动其实是多线程的。
    			
    需求：我们要实现多线程的程序。
    如何实现呢?
    		由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来。
    		而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。
    		Java是不能直接调用系统功能的，所以，我们没有办法直接实现多线程程序。
    		但是呢?Java可以去调用C/C++写好的程序来实现多线程程序。
    		由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西，
    		然后提供一些类供我们使用。我们就可以实现多线程程序了。
    那么Java提供的类是什么呢?
    		Thread
    		通过查看API，我们知道了有2中方式实现多线程程序。
    
    方式1：继承Thread类。
    步骤
    		A:自定义类MyThread继承Thread类。
    		B:MyThread类里面重写run()?
    			为什么是run()方法呢?
    		C:创建对象
    		D:启动线程
    该类要重写run()方法,为什么呢?
    不是类中的所有代码都需要被线程执行的。
    而这个时候，为了区分哪些代码能够被线程执行，java提供了Thread类中的run()用来包含那些被线程执行的代码。
    
    面试题：run()和start()的区别?
    run():仅仅是封装被线程执行的代码，直接调用是普通方法
    start():首先启动了线程，然后再由jvm去调用该线程的run()方法。
    
    如何获取线程对象的名称呢?
    public final String getName():获取线程的名称。
    如何设置线程对象的名称呢?
    public final void setName(String name):设置线程的名称
     
    针对不是Thread类的子类中如何获取线程对象名称呢?
    public static Thread currentThread():返回当前正在执行的线程对象
    
    我要获取main方法所在的线程对象的名称，该怎么办呢?
    遇到这种情况,Thread类提供了一个很好玩的方法:
    public static Thread currentThread():返回当前正在执行的线程对象 
    
    我们的线程没有设置优先级,肯定有默认优先级。
    那么，默认优先级是多少呢?
    如何获取线程对象的优先级?
    		public final int getPriority():返回线程对象的优先级
    如何设置线程对象的优先级呢?
    		public final void setPriority(int newPriority)：更改线程的优先级。 
    
    注意：
    		线程默认优先级是5。
    		线程优先级的范围是：1-10。
    		线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。
    		
    IllegalArgumentException:非法参数异常。
    抛出的异常表明向方法传递了一个不合法或不正确的参数。
    
    线程休眠:public static void sleep(long millis)
    线程加入:public final void join():等待该线程终止。
    线程礼让: public static void yield()
    后台线程:public final void setDaemon(boolean on)
    public final void stop():让线程停止，过时了，但是还可以使用。
    public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。
    
    方式2：实现Runnable接口
    步骤：
    		A:自定义类MyRunnable实现Runnable接口
    		B:重写run()方法
    		C:创建MyRunnable类的对象
    		D:创建Thread类的对象，并把C步骤的对象作为构造参数传递
    
    实现接口方式的好处
    	可以避免由于Java单继承带来的局限性。
    	适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想
    	
    
    如何解决线程安全问题呢?
    
    要想解决问题，就要知道哪些原因会导致出问题:(而且这些原因也是以后我们判断一个程序是否会有线程安全问题的标准)
    A:是否是多线程环境
    B:是否有共享数据
    C:是否有多条语句操作共享数据
    
    我们来回想一下我们的程序有没有上面的问题呢?
    A:是否是多线程环境	是
    B:是否有共享数据	是
    C:是否有多条语句操作共享数据	是
    
    由此可见我们的程序出现问题是正常的，因为它满足出问题的条件。
    接下来才是我们要想想如何解决问题呢?
    A和B的问题我们改变不了，我们只能想办法去把C改变一下。
    思想：
    		把多条语句操作共享数据的代码给包成一个整体，让某个线程在执行的时候，别人不能来执行。
    问题是我们不知道怎么包啊?其实我也不知道，但是Java给我们提供了：同步机制。
    
    同步代码块：
    		synchronized(对象){
    			需要同步的代码;
    		}
    
    		A:对象是什么呢?
    			我们可以随便创建一个对象试试。
    		B:需要同步的代码是哪些呢?
    			把多条语句操作共享数据的代码的部分给包起来
    
    		注意：
    			同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。
    			多个线程必须是同一把锁。
    
    
    同步的特点：
    		前提：
    			多个线程
    		解决问题的时候要注意：
    			多个线程使用的是同一个锁对象
    同步的好处 
    		同步的出现解决了多线程的安全问题。
    同步的弊端
    		当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。
    
    
    A:同步代码块的锁对象是谁呢?
    		任意对象。
    
    B:同步方法的格式及锁对象问题?
    		把同步关键字加在方法上。
    
    		同步方法是谁呢?
    			this
    
    C:静态方法及锁对象问题?
    		静态方法的锁对象是谁呢?
    			类的字节码文件对象。(反射会讲) 
    
    