### 多线程
    Lock
    	void lock()
    	void unlock()
    ReentrantLock
    
    分析：
    		资源类：Student	
    		设置学生数据:SetThread(生产者)
    		获取学生数据：GetThread(消费者)
    		测试类:StudentDemo
    
    问题1：按照思路写代码，发现数据每次都是:null---0
    原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个
    如何实现呢?
    		在外界把这个数据创建出来，通过构造方法传递给其他的类。
    
    问题2：为了数据的效果好一些，我加入了循环和判断，给出不同的值,这个时候产生了新的问题
    		A:同一个数据出现多次
    		B:姓名和年龄不匹配
    原因：
    		A:同一个数据出现多次
    			CPU的一点点时间片的执行权，就足够你执行很多次。
    		B:姓名和年龄不匹配
    			线程运行的随机性
    线程安全问题：
    		A:是否是多线程环境		是
    		B:是否有共享数据		是
    		C:是否有多条语句操作共享数据	是
    解决方案：
    		加锁。
    		注意：
    			A:不同种类的线程都要加锁。
    			B:不同种类的线程加的锁必须是同一把。
    			
    问题3:虽然数据安全了，但是呢，一次一大片不好看，我就想依次的一次一个输出。
    如何实现呢?
    		通过Java提供的等待唤醒机制解决。
    
    等待唤醒：
    		Object类中提供了三个方法：
    			wait():等待
    			notify():唤醒单个线程
    			notifyAll():唤醒所有线程
    		为什么这些方法不定义在Thread类中呢?
    			这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。
    			所以，这些方法必须定义在Object类中。
### 线程组
    Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。
    默认情况下，所有的线程都属于主线程组。
    	public final ThreadGroup getThreadGroup()
    我们也可以给线程设置分组
    	Thread(ThreadGroup group, Runnable target, String name)

### 线程池
    线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
    
    如何实现线程的代码呢?
    		A:创建一个线程池对象，控制要创建几个线程对象。
    			public static ExecutorService newFixedThreadPool(int nThreads)
    		B:这种线程池的线程可以执行：
    			可以执行Runnable对象或者Callable对象代表的线程
    			做一个类实现Runnable接口。
    		C:调用如下方法即可
    			Future<?> submit(Runnable task)
    		<T> Future<T> submit(Callable<T> task)
    	D:我就要结束，可以吗?
    		可以。
    
    匿名内部类的格式：
     		new 类名或者接口名() {
     			重写方法;
     		};
     		本质：是该类或者接口的子类对象。
     		
### 多线程常见面试题    
    1:多线程有几种实现方案，分别是哪几种?
    	两种。
    	
    	继承Thread类
    	实现Runnable接口
    	
    	扩展一种：实现Callable接口。这个得和线程池结合。
    
    2:同步有几种方式，分别是什么?
    	两种。
    	
    	同步代码块
    	同步方法
    
    3:启动一个线程是run()还是start()?它们的区别?
    	start();
    	
    	run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用
    	start():启动线程，并由JVM自动调用run()方法
    
    4:sleep()和wait()方法的区别
    	sleep():必须指时间;不释放锁。
    	wait():可以不指定时间，也可以指定时间;释放锁。
    
    5:为什么wait(),notify(),notifyAll()等方法都定义在Object类中
    	因为这些方法的调用是依赖于锁对象的，而同步代码块的锁对象是任意锁。
    	而Object代码任意的对象，所以，定义在这里面。
    
    6:线程的生命周期图
    	新建 -- 就绪 -- 运行 -- 死亡
    	新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡
    	建议：画图解释。
			